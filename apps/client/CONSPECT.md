**Сегмент** URL: часть пути URL, разделенная косой чертой.
**URL-путь:** часть URL-адреса, которая идет после домена (состоит из сегментов).

App Router построен на компонентах React Server и поддерживает общие макеты, вложенную маршрутизацию, состояния
загрузки, обработку ошибок и многое другое.

Next.js использует маршрутизатор на основе файловой системы, где:
Папки используются для определения маршрутов.
Маршрут - это единый путь к вложенным папкам,
следующий по иерархии файловой системы от корневой папки до конечной папки, которая включает page.js файл.
Файлы используются для создания пользовательского интерфейса, который отображается для сегмента маршрута.

**Private Folders**
Личные папки можно создавать, добавляя к папке символ подчеркивания: _folderName.
Это указывает на то, что папка является частной деталью реализации и не должна учитываться системой маршрутизации, тем
самым исключая папку и все ее подпапки вне маршрутизации.
Файлы в каталоге app могут быть безопасно размещены по умолчанию, для совместного размещения не требуются личные
папки.
Личные папки могут быть полезны для:
Отделение логики пользовательского интерфейса от логики маршрутизации.
Последовательная организация внутренних файлов в рамках проекта и экосистемы Next.js.
Сортировка и группировка файлов в редакторах кода.
Избежать потенциальных конфликтов имен с будущим Next.js файл конвенций.

Чтобы создать маршрут, содержащий в начале "_" нужно использовать код символа "_" в начале названия папки - %5F.

#### Специальные файлы:

page.tsx
layout.tsx
template.tsx
not-found.tsx
error.tsx
default.tsx

**Иерархия компонентов**
Компоненты React, определенные в специальных файлах сегмента маршрута, отображаются в определенной иерархии:

layout.js
template.js
error.js (Граница ошибки React)
loading.js (Граница ожидания реакции)
not-found.js (Граница ошибки React)
page.js или вложенное layout.js

**page.tsx** - Уникальный пользовательский интерфейс маршрута и возможность сделать маршруты общедоступными

**layout.tsx** - Общий пользовательский интерфейс для сегмента и его дочерних элементов.
Позволяет сохранять состояние при навигации по их children.
При загрузке контента вложенных сегментов интерфейс макета (layout) остаётся интерактивным.

**template.tsx** - Специализированный переработанный пользовательский интерфейс макета. Не сохраняет состояние при
навигации по вложенным сегментам маршрута.

**not-found.tsx** - Не найден пользовательский интерфейс для сегмента и его дочерних элементов.
import { notFound } from 'next/navigation'
notFound-функция позволяет отображать not-found file в пределах сегмента маршрута, а также вводить <meta
name="robots" content="noindex" /> тег.
Вызов notFound() функции выдает NEXT_NOT_FOUND ошибку и завершает визуализацию сегмента маршрута, в котором она была
вызвана. Указание не найденного файла позволяет корректно обрабатывать такие ошибки путем отображения не найденного
пользовательского интерфейса внутри сегмента.

**default.tsx** - Резервный пользовательский интерфейс для параллельных маршрутов.

**error.tsx** - Ошибка пользовательского интерфейса для сегмента и его дочерних элементов. Ошибки сегмента маршрута, в
папке которого расположен error.tsx, может обработать только файл, расположенный на уровень выше.

#### [Error Handling - обработка ошибок](https://nextjs.org/docs/app/building-your-application/routing/error-handling)

error.js автоматически создает Границу ошибки React (React Error Boundary) , которая обтекает вложенный дочерний сегмент
или page.js компонент.
Компонент React, экспортированный из файла error.js , используется в качестве резервного компонента.
Если в пределах границы возникает ошибка, отображается резервный компонент, экспортируемый файлом error.tsx.
Когда активен резервный компонент ошибки, макеты выше границы ошибки сохраняют свое состояние и остаются интерактивными,
а компонент ошибки может отображать функциональность для восстановления после ошибки.

export default function Error({error,reset,}: {error: Error & { digest?: string } reset: () => void})

Компонент ошибки может использовать функцию reset(), которую принимает через props, чтобы предложить пользователю 
попытаться исправить ошибку.
При вызове reset() Next.js попытается повторно отобразить содержимое границы ошибки.
В случае успеха резервный компонент ошибки заменяется результатом повторного рендеринга.

Вызвав props reset (function) в ErrorBoundary, можно повторно выполнить действие, вызвавшее ошибку, например,
отправить запрос на сервер.
React Error Boundary

#### [Dynamic Routes](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes)

Динамический сегмент можно создать, заключив имя файла или папки в квадратные скобки: [segmentName]. Например, [id]
или [slug].
Доступ к динамическим сегментам можно получить с useRouter.

import { useRouter } from 'next/router'
export default function Page() {
const router = useRouter()
return <p>Post: {router.query.slug}</p>
}

Получить доступ к параметрам маршрута можно также путём деструктуризации props в компонентах.
export default async function Reception({params,}: {params: { date: string; timeInterval: string };
})

**Catch-all Segments**
Динамические маршруты можно расширить до маршрутов, перехватывающих все сегменты, добавив многоточие внутри скобок [...
segmentName]

**Optional Catch-all Segments**
Необязательные универсальные маршруты можно создать, заключив параметр в двойные квадратные скобки: [[...segmentName]].
Разница между сегментами catch-all и optional catch-all заключается в том, что с параметром optional также
сопоставляется маршрут без параметра.

#### Программная навигация

import { useRouter } from "next/navigation";
const router = useRouter();

Перенаправление на другую страницу
router.push("/orders");

Возврат на предыдущую страницу
router.back()

Переход на следующую страницу
router.forward();

Перезапись истории браузера, чтобы устранить возможность вернуться на предыдущую страницу.
router.replace("/");

**Выделение активных ссылок в меню**
import { usePathname } from "next/navigation";
const pathname = usePathname();
const isActive = pathname.startsWith(link.href);
className={isActive ? "font-bold" : ""}

#### [Route Groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups)

В app каталоге вложенные папки обычно сопоставляются с URL-путями. Однако вы можете пометить папку как группу маршрутов,
чтобы предотвратить включение папки в URL-адрес маршрута.
Группу маршрутов можно создать, заключив имя папки в круглые скобки: (folderName).

#### [Metadata](https://nextjs.org/docs/app/building-your-application/optimizing/metadata)

Next.js имеет API метаданных, который можно использовать для определения метаданных вашего приложения (например, meta и
link тегов внутри вашего элемента HTML head) для улучшения SEO и возможности совместного использования в Интернете.

Метаданные оцениваются по порядку, начиная с корневого сегмента и заканчивая сегментом, ближайшим к конечному page.js
сегменту.
Следуя порядку оценки, объекты метаданных, экспортированные из нескольких сегментов одного маршрута, неглубоко
объединяются вместе для формирования конечных выходных метаданных маршрута. Дублирующиеся ключи заменяются в зависимости
от их порядка.

**Метаданные на основе конфигурации:**
Экспортируйте статический metadata объект или динамическую generateMetadata функцию в файл layout.js или page.js

**Метаданные на основе файлов:** добавление статических или динамически генерируемых специальных файлов к сегментам
маршрута.
Эти специальные файлы доступны для метаданных:

favicon.ico, apple-icon.jpg, и icon.jpg
opengraph-image.jpg и twitter-image.jpg
robots.txt
sitemap.xml

**Parallel Routes - параллельные маршруты**
Параллельные маршруты позволяют одновременно или с определенными условиями отображать одну или несколько страниц в одном
макете. Они полезны для высокодинамичных разделов приложения, таких как информационные панели и каналы на социальных
сайтах.
Достоинство Parallel Routes заключается в независимой обработке маршрутов и субнавигации.
Параллельные маршруты создаются с использованием именованных слотов. Слоты определяются с помощью @folder соглашения.
Для создания slot нужно создать папку, название которой начинается с @, на том же уровне вложенности, что и layout.tsx.
При этом папки слотов не будут участвовать в маршрутизации.
Чтобы подключить слоты к layout, нужно принять их через props.
children Prop - это неявный слот, который не нужно сопоставлять с папкой. Это означает, что app/page.js эквивалентно
app/@children/page.js

Каждый слот может иметь независимый индикатор загрузки и обработчик ошибок. Внутри каждого параллельного маршрута
возможна независимая плавная навигация. Каждый слот - мини-приложение со своим состоянием и навигацией. Параллельные
маршруты позволяют одновременно отображать разные страницы в рамках одного макета.

По-умолчанию содержимое, отображаемое в каждом слоте, соответствует текущему url-адресу.
При переходе по url-адресу, соответствующему вложенному маршруту одного из слотов, происходит замена отображаемого
компонента только для слота, имеющего сегмент, совпадающий с новым url-адресом. Состояние остальных слотов не
изменяется, т.к. их сегменты являются несовпадающими (**Unmatched**) с новым url.
При перезагрузке страницы Next.js отображает default.tsx для каждого unmatched slot.
Если default.tsx заданы не для всех unmatched slot, то перезагрузка страницы в браузере вызовет ошибку '404'.
**default.js** Файл используется для отрисовки резервной копии в рамках параллельных маршрутов, когда Next.js не удается
восстановить активное состояние слота после загрузки всей страницы.

При параллельной маршрутизации содержимое слота обычно соответствует текущему url.
При навигации из пользовательского интерфейса для unmatched slot отображается предыдущее активное состояние слота 
(его содержимое не изменяется).
При принудительной перезагрузке страницы содержимое unmatched slot заменяется дефолтным, если оно не определено, то 
возникает ошибка '404'.

Параллельные маршруты предлагают способ реализации условной маршрутизации, например, в зависимости от состояния 
аутентификации пользователя:
- отображение контента для аутентифицированных пользователей;
- страницу аутентификации - для остальных.
Для этих целей удобно использовать контекст React.

**Intercepting Routes - перехватывающие маршруты**
Перехватывающие маршруты позволяют загружать маршрут из другой части приложения в рамках текущего макета.
Это бывает полезно, когда нужно отобразить содержимое маршрута без переключения пользователя на другой контекст.
Например, для отображения модального окна аутентификации поверх текущего макета. При этом текущий url-адрес 
изменяется на url-страницы входа в систему (/login).
Или для отображения увеличенного изображения поверх страницы с миниатюрами. url-адрес изменяется на /pictures/[id]. При 
этом клик на увеличенную фотографию нв фото в модальном окне приведёт к переходу на страницу этой фотографии 
(/pictures/id).

Соглашения:
1) Добавление (.) в начало названия папки, соответствующей перехватываемому маршруту. Папка должна находиться на том 
   же уровне вложенности, что и перехватываемый маршрут. Название папки должно совпадать с названием папки 
   перехватываемого маршрута с добавлением (.) в начале названия.   
2) Если добавить к названию папки перехватываемого сегмента (..), то она будет соответствовать перехватываемому
   сегменту маршрута, папка которого расположена на один уровень вложенности выше.
3) Если добавить к названию папки перехватываемого сегмента (..)(..), то она будет перехватывать сегменты маршрута, 
   соответствующие папке, расположенной на два уровня выше в иерархии папок.
4) Если добавить к названию папки перехватываемого сегмента (...), то она будет перехватывать сегменты маршрута,
   соответствующие корневой папке приложения (/app).
5) 

#### Route Handlers - бработчики маршрутов
бработчики маршрутов позволяют создавать пользовательские обработчики запросов для заданного маршрута,
используя веб-API для запроса и ответа.
Обработчики маршрутов доступны только внутри app каталога.
Они эквивалентны маршрутам API внутри pages каталога.
Это означает, что вам не нужно использовать маршруты API и обработчики маршрутов вместе.

Соглашение:
Обработчики маршрутов определяются в route.js|ts файле внутри app.
Не может быть route.js файла на том же уровне сегмента маршрута, что и page.js (page.js будет проигнорирован).
Обработчики маршрутов должны экспортировать асинхронные функции с названиями,
соответствующими HTTP-методам GET, POST, PUT, PATCH DELETE, HEAD OPTIONS.

Поддерживаются следующие HTTP-методы: GET, POST, PUT, PATCH DELETE, HEAD OPTIONS.
Если вызывается неподдерживаемый метод, Next.js вернет 405 Method Not Allowed ответ.

Расширенные NextRequest и NextResponse API
В дополнение к поддержке нативных Request и Response Next.js расширяет их с помощью NextRequest и NextResponse,
предоставляя удобные помощники для продвинутых вариантов использования.

Обработчики маршрутов кэшируются по умолчанию при использовании GET метода с Response объектом.
Кэширование можно отключать.
Можно задавать время ревалидации данных, экспортировав константу revalidate из файла page.tsx или route.tsx:
//layout.js | page.js
export const revalidate = 3600

Значение cookie можно устанавливать и читать с помощью cookies from next/headers.
Эта серверная функция может быть вызвана непосредственно в обработчике маршрутов или вложена внутрь другой функции.
const cookieStore = cookies()
const token = cookieStore.get('token')

Для чтения файлов cookie из запроса можно использовать тип NextRequest.
import { type NextRequest } from 'next/server'
export async function GET(request: NextRequest) {
const token = request.cookies.get('token')
}

Также доступны чтение и установка заголовков, а также перенаправления:
import { headers } from 'next/headers'
export async function GET(request: Request) {
const headersList = headers()
const referer = headersList.get('referer')
return new Response('Hello, Next.js!', {
status: 200,
headers: { referer: referer },
})
}

import { redirect } from 'next/navigation'

export async function GET(request: Request) {
redirect('https://nextjs.org/')
}

# TurboRepo

Файлы .env каждого приложения рекомендуется хранить в папке приложения, которое его использует.
Для использования типов данных NestJS в tsconfig.json Next.js нужно включить опцию "experimentalDecorators": true.
При сборке приложения Next.js следует устанавливать значение переменно среды окружения NODE_ENV=production.

